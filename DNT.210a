#!/usr/bin/env python3
# DNT -- Display Temperatures from neighborhood remote thermometers
# Modeled after
#   https://learn.sparkfun.com/tutorials/python-gui-guide-introduction-to-tkinter/experiment-3-sensor-dashboard
#
# HDTodd, Williston, VT, February, 2023; v2 April, 2023

import argparse, sys, os, signal
from paho.mqtt import client as mqtt_client
import tkinter as tk
import tkinter.font as tkFont
import random
import json
import time
import datetime

AP_DESCRIPTION="""
DNT:  Display the temperatures of neighborhood remote thermometer sensors
      as observed and published as MQTT by rtl_433.
"""

AP_EPILOG="""

"""

###############################################################################
##  *** BEGIN LOCAL MODIFICATIONS ***

# Locations of known local sensors to be monitored
# Dictionary entries are "model/channel/id":"Familiar Name".
# Run this program from a terminal session to see a list of "model/channel/id"
#   dictionary keywords for devices in your neighborhood, then add entries with
#   those keywords and associated locations into the 'location' dictionary here

location = {
    "Acurite-609TXC//51"       : "Outside",
    "Acurite-606TX//161"       : "Porch",
    }
# Display known remote sensors; size to allow for header row

##  *** END LOCAL MODIFICATIONS ***

###############################################################################
# Global variable initialization

# MQTT connection management
# Parameters used to establish the mqtt connection to the rtl_433 receiver mqtt publisher
broker = None
topic = "rtl_433/+/events"
port = 1883
username = ""
password = ""
client_id = f'python-mqtt-{random.randint(0, 100)}'

# By default, use Fahrenheit scale for display
useF=True
tScale = "°F"

# Remember if we are fullscreen or windowed; toggle starts fullscreen
win = None
frm_table = None
fullscreen = False
dfont = None
hfont = None
lfont = None
first_rec = True
debug     = False
devnum = None

# Set 2-sec threshhold for rejecting duplicate records
dup_thresh = 2.0

##########################################################################################
# Define a class to hold the data for a device and procedures to create, update, access
class Data:
    def __init__(self, dRow, eTime, loc, temp, rh, battery, status):
        self.last_time = eTime
        self.loc       = loc
        self.temp      = temp
        self.rh        = rh
        self.battery   = battery
        self.status    = status
        self.dRow      = dRow
        return

    # Update information about this device and return a
    #  flag to indicate if it was a duplicate record for this xmit
    def update(self, eTime, temp, rh, battery, status):
        dup = eTime < self.last_time + dup_thresh
        self.last_time = eTime
        self.temp      = temp
        self.rh        = rh
        batt_change    = battery != self.battery
        self.battery   = battery
        stat_change    = status != self.status
        self.status    = status
        return (dup, batt_change, stat_change)

###############################################################################
#  Create the command parser, parse cmd line,  and set defaults
def make_parser():

    parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter,
                                     description=AP_DESCRIPTION,
                                     epilog=AP_EPILOG)

    parser.add_argument("-H", "--host", dest="host", type=str, default=broker,
                        help="MQTT broker hostname to connect to (default: %(default)s)")
    parser.add_argument("-T", "--topic", dest="topic", type=str, default=topic,
                        help="rtl_433 MQTT event topic to subscribe to (default: %(default)s)")
    parser.add_argument("-U", "--username", type=str, default=username,
                        help="MQTT username, if needed; defaults to blank")
    parser.add_argument("-P", "--password", type=str, default=password,
                        help="MQTT password, if needed; defaults to blank")
    parser.add_argument("-p", "--port", type=int, default=port,
                        help="MQTT port (default: %(default)s)")
    parser.add_argument("-d", "--debug", dest="debug", action="store_true")
    specifyTemp = parser.add_mutually_exclusive_group()
    specifyTemp.add_argument("-C", "--Celsius", dest="degC", action="store_true",
                             default=False,
                             help="Display temperatures in Celsius (default is Fahrenheit)")
    specifyTemp.add_argument("-F", "--Fahrenheit", dest="degC", action="store_false",
                             default=True,
                             help="Display temperatures in Fahrenheit (default)")
    args = parser.parse_args()
    return args

###############################################################################
# Set execution parameters from cmdline
def set_params():
    global broker, topic, username, password, port, useF, tScale, debug

    args = make_parser()

    #  We need host and topic, so if not already provided by
    #    cmdline, env, or embedded source code, then ask for them
    if not args.host:
        if "MQTT_HOST" in os.environ:
            args.host = os.environ["MQTT_HOST"]
        else:
            if broker == None:
                args.host = input("MQTT host name or IP: ")

    if not args.topic:
        if "MQTT_TOPIC" in os.environ:
            args.topic = os.environ["MQTT_TOPIC"]
        else:
            if topic == None:
                args.topic = input("MQTT topic: ")

    #  username and password not required, so don't prompt if not already provided
    #    and port just defaults
    if not args.username and 'MQTT_USERNAME' in os.environ:
        args.username = os.environ['MQTT_USERNAME']
    else:
        args.username = ""

    if not args.password and 'MQTT_PASSWORD' in os.environ:
        args.password = os.environ['MQTT_PASSWORD']
    else:
        args.password = ""

    if not args.port and 'MQTT_PORT' in os.environ:
        args.port = os.environ['MQTT_PORT']

    useF     = False if args.degC!=None and args.degC else True
    tScale = "°F" if useF else "°C"
    broker   = args.host
    topic    = args.topic
    username = args.username
    password = args.password
    port     = args.port
    debug    = args.debug
    if debug:
        print("Debug is ON")
        print("Parameter settings in execution are ...")
        print("\tMQTT host:    ", broker)
        print("\tMQTT topic:   ", topic)
        print("\tMQTT username:", username)
        print("\tMQTT password:", password)
        print("\tMQTT port:    ", port)
        print("\tUseF:         ", useF)

    return

###############################################################################
# Convert time from various formats to epoch time
def CnvTime(ts):
    if ts.find("-") > 0:
        try:
            eTime = datetime.datetime.fromisoformat(ts).timestamp()
        except ValueError as e:
            err={}
            print("datetime error in input line converting time string: ", ts)
            print("datetime  msg:", err.get("error", str(e)))
            sys.exit(1)
    else:
        try:
            eTime = float(ts)
        except ValueError as e:
            err = {}
            print("Datetime conversion failed on line with datetime string", ts)
            print("float() error msg:", err.get("error", str(e)))
            sys.exit(1)
    return eTime


###############################################################################
# Functions for displaying

# Toggle fullscreen
def toggle_fullscreen(event=None):
    global win
    global fullscreen

    fullscreen = not fullscreen
    win.attributes('-fullscreen', fullscreen)
    resize()
    return

# Automatically resize font size based on window size
def resize(event=None):
    global dfont
    global lfont
    global win

    # Resize font based on frame height (minimum size of 12)
    # Use negative number for "pixels" instead of "points"
    hfont.configure(size=-max(36, int((win.winfo_height() / 18))))
    dfont.configure(size=-max(24, int((win.winfo_height() / 24))))
    lfont.configure(size=-max(30, int((win.winfo_height() / 24))))

#    for j in range(3):
#        tbl[0][j].configure(font=lfont)
#        for i in range(1,displaySize-1):
#            tbl[i][j].configure(font=dfont)

#    btn_quit.config(font=dfont)
#    btn_toggle.config(font=dfont)
    return

#######################################################################################
# Table management and display

def add_row(devnum, loc, temp, hum):
    global frm_table
    row = tk.Frame(frm_table)
    tblrow.append(row)
    # Color the header row differently
    bg = "cornflower blue" if devnum==0 else "white"
    fg = "white"               if devnum==0 else "black"
    lbl_loc  = tk.Label(row, width=30, textvariable=loc,  font=dfont, bg=bg, fg=fg)
    lbl_temp = tk.Label(row, width=10, textvariable=temp, font=dfont, bg=bg, fg=fg)
    lbl_hum  = tk.Label(row, width=10, textvariable=hum,  font=dfont, bg=bg, fg=fg)

    lbl_loc.grid( row=devnum, column=0, padx=5, pady=5, sticky=tk.W)
    lbl_temp.grid(row=devnum, column=1, padx=5, pady=5, sticky=tk.E)
    lbl_hum.grid( row=devnum, column=2, padx=5, pady=5, sticky=tk.E)
    return (devnum+1, row)

###############################################################################
# MQTT functions and display updating
# Connect to  MQTT broker
def connect_mqtt() -> mqtt_client:
    global debug
    def on_connect(mqtt, userdata, flags, rc):
        if rc == 0:
            if debug:
                print("Connected to MQTT Broker!")
        else:
            print("Failed attempt to connect to ", mqtt)
            print("  with userdata ", userdata)
            print("Return code %d\n", rc)

    mqtt = mqtt_client.Client(client_id, clean_session=False)
    mqtt.username_pw_set(username, password)
    mqtt.on_connect = on_connect
    mqtt.connect(broker, port)
    subscribe(mqtt)
    return mqtt

# Subscribe to rtl_433 publication & process records we receive
def subscribe(mqtt: mqtt_client):

    # on_message does the real work
    # When we get a thermometer reading,
    #   ignore if it's a duplicate, update display if it isn't
    def on_message(mqtt, userdata, msg):
        global first_rec, last_rec
        global devices, devnum, tbl

        # parse the json payload
        y = json.loads(msg.payload.decode())

        # If not a device record, just return
        if not "model" in y:
            return

        #  Create the device identifier as "model/channel/id"
        dev = y["model"] + "/"
        if "channel" in y:
            dev += str(y["channel"])
        dev += "/"
        if "id" in y:
            dev += str(y["id"])

        # if this is a themometer reading, process it; otherwise just return
        if "temperature_C" in y.keys():
            ltemp = y["temperature_C"]
            if useF:
                ltemp = ltemp*9.0/5.0+32.0
        else:
            if "temperature_F" in y.keys():
                ltemp = y["temperature_F"]
                if not useF:
                    ltemp = (ltemp-32.0)*5.0/9.0
            else:
                return   # if no temp reading in record, ignore it

        # OK, we have a temp reading. Get the variables we need
        eTime   = CnvTime(y["time"])
        loc     = dev if dev not in location else location[dev]
        hum     = 0 if not ("humidity" in y.keys()) else int(y["humidity"])
        battery = None if "battery_ok" not in y else y["battery_ok"]
        status  = None if "status"     not in y else y["status"]

        # Got all the values: add or update if not a repeated packet
        if dev in devices:
            # See if this is a duplicate (repeated) packet,
            #   update the values in the dictionary,
            #   and retrieve location field and display table row number
            (dup, batt_change, stat_change) = devices[dev].update(eTime, ltemp, hum, battery, status)
            dRow = devices[dev].dRow
        else:
            # Add a new device
            # Add the device to the table
            devices[dev] = Data(devnum, eTime, loc, ltemp, hum, battery, status)
            # Set values needed for subsequent processing
            dRow = devnum
            (dup, batt_change, stat_change) = (False, False, False)
            # Append the display variables for this row to the display table
            #   and increment devnum
            tbl.append( (tk.StringVar(), tk.StringVar(), tk.StringVar() ) )
            # Create the row and point to the display table variables
            (devnum, row) = add_row(devnum, tbl[devnum][0], tbl[devnum][1], tbl[devnum][2])
            row.pack(side="top")

        if not dup:
            if debug:
                 print("Updating display table row ", dRow, "for", loc)
                 print("{:<3d} {:<30} {:<20} {:<30} {:>8.1f}{:2} {:>5}% snr={:>3.0f}".format(
                     dRow,
                     loc,
                     y["time"],
                     dev,
                     round(ltemp,1),
                     tScale,
                     hum,
                     0.0 if not ('snr' in y) else y['snr'])
                     )
            try:
                tbl[dRow][0].set(loc)
                tbl[dRow][1].set(round(ltemp,1))
                tbl[dRow][2].set(hum)
            except:
                print("exception when trying to set display values")
                pass
#            resize()
            return  #From on_message()

    mqtt.subscribe(topic)
    mqtt.on_message = on_message
    if debug:
        print("subscribed to mqtt feed")
    return #From subscribe()

# CNTL-C and QUIT button handler
def quit_prog(event=None):
    mqtt.loop_stop()
    print()
    time.sleep(1)      # let events clear (we hope)
    mqtt.disconnect()
    win.quit()
    sys.exit(0)


def create_display():    
    global win, frm_table, dfont, hfont, lfont, devnum
    # Create the main window
    win = tk.Tk()
    win.title("Neighborhood Temperatures")

    # Create dynamic font for text
    hfont = tkFont.Font(size=-36)
    dfont = tkFont.Font(size=-24)
    lfont = tkFont.Font(size=-30, weight="bold")

    # Build the title section of the display
    frm_title = tk.Frame(win, borderwidth=10, relief="groove")
    frm_title.pack(side="top", fill="x", expand=True)
    lbl_title = tk.Label(frm_title, text="Display Neighborhood Temperatures",
                         font=hfont, bg="cornflower blue", fg="white")
    lbl_title.pack(anchor="center", fill="x")

    # Build the menu button
#    frm_toolbar = tk.Frame(win)
#    frm_toolbar.pack(side="top", fill="x", expand=True)
#    btn_quit   = tk.Button(frm_toolbar, text="Quit",           width=6,  height=2,
#                           font=dfont, fg='red', command=quit_prog)
#    btn_toggle = tk.Button(frm_toolbar, text="Toggle\nScreen", width=10, height=2,
#                           font=dfont, fg='blue', command=toggle_fullscreen)
#    btn_quit.pack(side="right")
#    btn_toggle.pack(side="left")

    # Build the information section
    frm_info = tk.Frame(win, borderwidth=5, relief="raised")
    frm_info.pack(side="top", fill="x", expand=True)
    lbl_monitor = tk.Label(frm_info, text="Monitoring host: %s" % (broker), font=dfont)
    btn_toggle = tk.Button(frm_info, text="Togl",           width=4, height=1,
                           font=dfont, fg='blue', command=toggle_fullscreen)
    btn_quit   = tk.Button(frm_info, text="Quit",           width=4,  height=1,
                           font=dfont, fg='red',  command=quit_prog)                           
    lbl_monitor.pack(side="left", padx=2, pady=2)
    btn_quit.pack(side="right")
    btn_toggle.pack(side="right")


    # And create the table for data display
    frm_table = tk.Frame(win, borderwidth=5, relief="groove")
    frm_table.pack(side="top", fill="both", expand=True, padx=5, pady=5)

    # First, the header
    devnum  = 0
    tbl.append( (tk.StringVar(), tk.StringVar(), tk.StringVar() ) )
    (devnum, row)  = add_row(devnum, tbl[devnum][0], tbl[devnum][1], tbl[devnum][2])
    tbl[0][0].set("Location or Thermometer")
    tbl[0][1].set("Temp "+tScale)
    tbl[0][2].set("%RH")
    tblrow.append(row)
    row.pack(side="top")

    # Have <ESC> toggle window, and call resize() every time the window is resized
    win.bind('<Escape>', toggle_fullscreen)
#    win.bind("<ButtonRelease-1>", resize)
    return

###############################################################################
# Main script

if __name__ == "__main__":

    t = datetime.datetime.now()
    signal.signal(signal.SIGINT, quit_prog)

    set_params()

    # Device:Data dictionary
    devices = {}

    # List of widgets to display
    tbl = []
    tblrow = []

    # Create the display
    create_display()
    
    # connect to the mqtt broker and subscribe to the feed.
    #   MQTT events cause the displayed values to be updated
    mqtt = connect_mqtt()
    mqtt.loop_start()

    if debug:
        print("entering run loop")

    # Start the main loop and let MQTT events populate the display table
    win.mainloop()
